<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Final AyED by Andresteve07</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Final AyED</h1>
          <h2>
            Este repositorio contiene el código fuente del trabajo final para
            la materia Algoritmos y Estructuras de Datos (AyED) que se cursa en
            el primer cuatrimestre del tercer año de la carrera Ingeniería en
            Computación (ICOMP) en la Facultad de Ciencias Exactas Físicas
            (FCEFyN) y Naturales en la Universidad Nacional de Córdoba (UNC)
          </h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/Andresteve07/FINAL_AyED/zipball/master" id="download-zip" class="button">
              <span>Descarga en .zip</span>
            </a>
          <a href="https://github.com/Andresteve07/FINAL_AyED/tarball/master" id="download-tar-gz" class="button">
            <span>Descarga en .tar.gz</span>
          </a>
          <a href="https://github.com/Andresteve07/FINAL_AyED" id="view-on-github" class="button">
            <span>Repositorio en GitHub</span>
          </a>
        </section>

        <hr>

        <section id="main_content">
          <h3>
            <a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages">
              <span class="octicon octicon-link"></span>
            </a>
            Introducción
          </h3>

<p>
  El desarrollo tiene una primera fase donde se interpreta la consigna, para conocer el sistema (red de routers) a simular. Se realizo una descripción e implementación con orientación a objeto, permitiendo modularidad y hacer uso de herencia entre las clases Arco – Conexión.
Para ello, fueron necesarios los conocimientos brindados en clase de las estructuras implementadas como Nodo, Lista, Cola, Colas Anidadas, Grafo.
Una vez proyectado el sistema, en la segunda fase codificamos y adaptamos el Algoritmo de Dijkstra al sistema, dado que el resultado devuelto por el algoritmo, no es un valor de uso directo.
Por consigna, sabemos que los routers no son dispositivos autodidactas, es por ello, que existe un  ’Administrador’ que  cumple la función de gestionar, entre otras cosas,  la ejecución del algoritmo al inicio y cada 30 ciclos, que restablece los valores de las tablas de redireccionamiento de paquetes de cada Router perteneciente a la red. Es por ello, que a  partir del cálculo hecho por  el algoritmo, paralelamente se trazan las trayectorias más eficientes, es decir, la  secuencia de routers más eficiente.
La tercera fase, para verificar el modelo, realizamos 3 casos de uso, corroborando los valores arrojados por el algoritmo, y las tablas calculadas para cada router.
</p>


<h3>
  <a name="designer-templates" class="anchor" href="#designer-templates">
    <span class="octicon octicon-link"></span>
  </a>
  Algoritmo de Dijkstra
</h3>

<p>
  El algoritmo de Dijkstra resuelve el problema de los caminos más cortos y
  orígen único en un  grafo dirigido y ponderado $G=(V,E)$ tal que todos los
  pesos de los arcos son no negativos. Con una buena implementación el timepo
  de ejecución del algoritmo de Dijkstra es menor al de Bellman-Ford.
</p>

<h4>
  <a name="designer-templates" class="anchor" href="#designer-templates">
    <span class="octicon octicon-link"></span>
  </a>
  ¿Para qué sirve el algoritmo?
</h4>

<p>
La función del algoritmo es calcular los caminos mínimos que hay entre el nodo origen y todos los nodos del grafo.
</p>

<h4>
  <a name="designer-templates" class="anchor" href="#designer-templates">
    <span class="octicon octicon-link"></span>
  </a>
  ¿Cuál es  la lógica del algoritmo?
</h4>

<<p>
El algoritmo parte de un nodo inicial, y se va desplazando a través de  la red, guiándose por los nodos adyacentes al nodo actual.
Conforme el algoritmo evoluciona se encuentran mejores caminos para determinado nodo destino por lo que se actualiza el resultado. Finalmente el algoritmo termina cuando no quedan nodos sin camino mínimo encontrado.
Dijkstra mantiene un conjunto $S$ de nodos para los que ya se calcularon los caminos mínimos. El algoritmo cíclicamente selecciona un nodo $u \in (V-S)$ cuya distancia es la mínima entre los que quedan sin procesar, agrega el nodo seleccionado $u$ a $S$ y \textsc{ Relaja} todos los vértices adyacentes a $u$.
</p>

<pre><code>
  \begin{leftbar}
  \textsc{Dijkstra}(G, nodo\_inicio)\\
  1\indent	\textsc{Inicializar}(G)\\
  2\indent	$S=\emptyset$\\
  3\indent	$Q=G.V$\\
  4\indent	\textbf{while} ($Q\neq\emptyset$)\\
  5\indent\indent		nodo\_sel=\textsc{Mas Cercano}(Q)\\
  6\indent\indent		$S=S\cup nodo\_sel$\\
  7\indent\indent		\textbf{for each} $nodo\_i \in G.Adyacentes[nodo\_sel]$\\
  8\indent\indent\indent			\textsc{Relajar}(u,v)
  \end{leftbar}
</code></pre>

<p>
¿Como fue implementada dicha lógica?
Los elementos  que utilizamos son:
</p>

<ul>
    <li>Conjunto Q: conjunto de nodos no chequeados</li>
    <li>Conjunto S: conjunto de nodos chequeados</li>
    <li>Conjunto Adyacentes: conjunto de nodos adyacentes al nodo inicio</li>
    <li>Vector Predecesores: guarda los valores de los router predecesores a cada router</li>
    <li>Vector Distancias: almacena las distancias de los caminos mas cortos a cada router</li>
    <li>
      Lista de Etiquetas: contiene las etiquetas correspondiente a cada uno de los routers, con los valores en el siguiente formato:
      [r_destino, r_siguiente, peso del trayecto]
    </li>
</ul>

<p>
Primeramente, cargamos en conjunto Q , Adyacentes, las etiquetas, haciendo distinción para la etiqueta del nodo inicio \verb+{ orden_nodo_inicio, 0,0 }+ y las demás \verb+{ orden_nodo_x, -1, INF }+.
Luego recorremos en conjunto Q buscando en las etiquetas de cada uno de los routers, la que contenga el menor trayecto. Con esta condición, seleccionamos el nodo actual o elegido, y lo pasamos al conjunto S.
Luego recorremos los arcos, buscando aquellos que tengan origen en el nodo actual, y que su destino no corresponda a un nodo contenido en S.
Es entonces, cuando realizamos la comparación de distancias (trayectos almacenados en las etiquetas), con la distancia resultante de la suma de la distancia del trayecto desde el nodo inicio, al nodo actual, las la del trayecto del nodo actual al siguiente para determinar si actualizar o no los valores tanto en el peso de trayectoria, perteneciente a la etiqueta del router siguiente,  como en el Vector Distancias y Predecesores.

Seguidamente, normalizo y actualizo los valores en el Vector Predecesor, con los correspondientes valores de nodos adyacentes al nodo inicio, lo que nos permite posteriormente, armar las tablas para dicho router.
Finalmente, Se actualiza el campo \verb+r_siguiente+ de la etiqueta con el valor correspondiente,  calculado en dicho Vector de Predecesores. Terminando así la ejecución del algoritmo, devolviendo la tabla con los nuevos valores de redireccionamiento.

¿Qué diferencia tiene con Floyd-Warshall? Ambos algoritmos tienen la misma finalidad, obtener el calculo del camino mas corto. Pero la diferencia es que Dijkstra calcula los caminos partiendo desde un único nodo base, hasta los demás del grafo, mientras Floyd aplica lo mismo, pero para todos los nodos de la red.
Es decir, si el costo de calculo de Dijkstra es $n \times n$  operaciones, el costo de FFloyd-Warshall será $n \times n \times n$

</p>

<h3>
  <a name="authors-and-contributors" class="anchor" href="#authors-and-contributors">
    <span class="octicon octicon-link"></span>
  </a>
  Authors and Contributors
</h3>

<p>
  You can <a href="https://github.com/blog/821" class="user-mention">@mention</a>
  a GitHub username to generate a link to their profile. The resulting
  <code>&lt;a&gt;</code> element will link to the contributor's GitHub Profile.
  For example: In 2007, Chris Wanstrath
  (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>),
  PJ Hyett
  (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>),
  and Tom Preston-Werner
  (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>)
  founded GitHub.
</p>

<h3>
  <a name="support-or-contact" class="anchor" href="#support-or-contact">
    <span class="octicon octicon-link"></span>
  </a>
  Support or Contact
</h3>

<p>
  Having trouble with Pages? Check out the documentation at
  <a href="http://help.github.com/pages">http://help.github.com/pages</a>
  or contact <a href="mailto:support@github.com">support@github.com</a>
  and we’ll help you sort it out.
</p>
</section>

        <footer>
          Final AyED is maintained by
          <a href="https://github.com/Andresteve07">Andresteve07</a><br>
          This page was generated by
          <a href="http://pages.github.com">GitHub Pages</a>.
          Tactile theme by
          <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>


      </div>
    </div>
  </body>
</html>
